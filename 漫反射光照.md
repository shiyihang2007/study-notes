# [[OpenGL]] 相关

## 引入

[[环境光照]]本身不能提供最有趣的结果，但是漫反射光照就能开始对物体产生显著的视觉影响了。漫反射光照使物体上与光线方向越接近的[[片段]]能从光源处获得更多的亮度。为了能够更好的理解漫反射光照，请看下图：

![diffuse_light](https://learnopengl-cn.github.io/img/02/02/diffuse_light.png)

图左上方有一个光源，它所发出的光线落在物体的一个[[片段]]上。我们需要测量这个光线是以什么角度接触到这个[[片段]]的。如果光线垂直于物体表面，这束光对物体的影响会最大化（译注：更亮）。为了测量光线和[[片段]]的角度，我们使用一个叫做[[法向量]](Normal Vector)的东西，它是垂直于[[片段]]表面的一个向量（这里以黄色箭头表示），我们在后面再讲这个东西。这两个向量之间的角度很容易就能够通过点乘计算出来。

我们知道两个单位向量的夹角越小，它们点乘的结果越倾向于1。当两个向量的夹角为90度的时候，点乘会变为0。这同样适用于 $\theta$，$\theta$ 越大，光对[[片段]]颜色的影响就应该越小。

> 注意，为了（只）得到两个向量夹角的余弦值，我们使用的是单位向量（长度为1的向量），所以我们需要确保所有的向量都是标准化的，否则点乘返回的就不仅仅是余弦值了。

点乘返回一个标量，我们可以用它计算光线对[[片段]]颜色的影响。不同[[片段]]朝向光源的方向的不同，这些[[片段]]被照亮的情况也不同。

所以，计算漫反射光照需要什么？

- [[法向量]]：一个垂直于[[顶点]]表面的向量。
- 定向的光线：作为光源的位置与[[片段]]的位置之间向量差的方向向量。为了计算这个光线，我们需要光的位置向量和[[片段]]的位置向量。

## 计算漫反射光照

我们现在对每个[[顶点]]都有了[[法向量]]，但是我们仍然需要光源的位置向量和[[片段]]的位置向量。由于光源的位置是一个静态变量，我们可以简单地在[[片段着色器]]中把它声明为uniform：

```c++
uniform vec3 lightPos;
```

然后在渲染循环中（渲染循环的外面也可以，因为它不会改变）更新uniform。我们使用在前面声明的lightPos向量作为光源位置：

```c++
lightingShader.setVec3("lightPos", lightPos);
```

最后，我们还需要[[片段]]的位置。我们会在世界空间中进行所有的光照计算，因此我们需要一个在世界空间中的[[顶点]]位置。我们可以通过把[[顶点]]位置属性乘以模型矩阵（不是观察和投影矩阵）来把它变换到世界空间坐标。这个在[[顶点着色器]]中很容易完成，所以我们声明一个输出变量，并计算它的世界空间坐标：

```c++
out vec3 FragPos;  
out vec3 Normal;

void main()
{
    gl_Position = projection * view * model * vec4(aPos, 1.0);
    FragPos = vec3(model * vec4(aPos, 1.0));
    Normal = aNormal;
}
```

最后，在[[片段着色器]]中添加相应的输入变量。

```c++
in vec3 FragPos;
```

现在，所有需要的变量都设置好了，我们可以在[[片段着色器]]中添加光照计算了。

我们需要做的第一件事是计算光源和[[片段]]位置之间的方向向量。前面提到，光的方向向量是光源位置向量与[[片段]]位置向量之间的向量差。你可能记得在[变换](https://learnopengl-cn.github.io/01%20Getting%20started/07%20Transformations/)教程中，我们能够简单地通过让两个向量相减的方式计算向量差。我们同样希望确保所有相关向量最后都转换为单位向量，所以我们把法线和最终的方向向量都进行标准化：

```c++
vec3 norm = normalize(Normal);
vec3 lightDir = normalize(lightPos - FragPos);
```

当计算光照时我们通常不关心一个向量的模长或它的位置，我们只关心它们的方向。所以，几乎所有的计算都使用单位向量完成，因为这简化了大部分的计算（比如点乘）。所以当进行光照计算时，确保你总是对相关向量进行标准化，来保证它们是真正地单位向量。忘记对向量进行标准化是一个十分常见的错误。

下一步，我们对norm和lightDir向量进行点乘，计算光源对当前[[片段]]实际的漫反射影响。结果值再乘以光的颜色，得到漫反射分量。两个向量之间的角度越大，漫反射分量就会越小：

```c++
float diff = max(dot(norm, lightDir), 0.0);
vec3 diffuse = diff * lightColor;
```

如果两个向量之间的角度大于90度，点乘的结果就会变成负数，这样会导致漫反射分量变为负数。为此，我们使用max函数返回两个参数之间较大的参数，从而保证漫反射分量不会变成负数。负数颜色的光照是没有定义的，所以最好避免它，除非你是那种古怪的艺术家。

现在我们有了环境光分量和漫反射分量，我们把它们相加，然后把结果乘以物体的颜色，来获得[[片段]]最后的输出颜色。

```c++
vec3 result = (ambient + diffuse) * objectColor;
FragColor = vec4(result, 1.0);
```

如果你的应用(和[[着色器]])编译成功了，你可能看到类似的输出：

![](https://learnopengl-cn.github.io/img/02/02/basic_lighting_diffuse.png)

